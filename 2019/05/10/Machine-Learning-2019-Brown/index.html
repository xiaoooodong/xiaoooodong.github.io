<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="Basicly, this course focuses on supervised learning all through the semester. I’m writing this note in order to give myself a deeper understanding of ">
    

    <!--Author-->
    
        <meta name="author" content="Xiaodong">
    

    <!-- Title -->
    
    <title>Machine Learning 2019 @ Brown | xiaoodong</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Noto+Serif:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
<meta name="generator" content="Hexo 7.3.0"></head>

<body>

    <!-- Content -->
    <section class="article-container">
<!-- Back Home -->
<a class="nav-back" href="/">
    <i class="fa fa-puzzle-piece"></i>
</a>

<!-- Page Header -->
<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Machine Learning 2019 @ Brown</h1>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Main Content -->
            <div class="post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- toc -->
<p>Basicly, this course focuses on supervised learning all through the semester. I’m writing this note in order to give myself a deeper understanding of all these stuffs.</p>
<h2 id="Linear-Predictors"><a href="#Linear-Predictors" class="headerlink" title="Linear Predictors"></a>Linear Predictors</h2><h3 id="Halfspace"><a href="#Halfspace" class="headerlink" title="Halfspace"></a>Halfspace</h3><p>$$ h_w(x) &#x3D; \langle w,x \rangle + b $$</p>
<p>b is bias. We can write simpler if we append a <code>1</code> at the end of each $ x $ and append <code>b</code> to the end of $ w $:</p>
<p>$$ h_w(x) &#x3D; sign(\langle w,x \rangle) $$</p>
<h4 id="Perceptron-Algorithm"><a href="#Perceptron-Algorithm" class="headerlink" title="Perceptron Algorithm"></a>Perceptron Algorithm</h4><p>It’s an iterative algorithm that goes through all samples repeatly until convergence. Everytime it meets a falsely classified data $ x $, update $ w $ as:</p>
<p>$$ w^{t+1} &#x3D; w^{t} + y_ix_i $$</p>
<p>$ y_i $ is the true lable for $ x_i $.</p>
<h3 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h3><p>$$ h_w(x) &#x3D; \langle w,x \rangle $$</p>
<p>Bias included. The output of $ h_w(x) $ is our prediction, it’s a real number in most cases.</p>
<h4 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h4><p>Usually we use mean squared loss in linear regression problems:</p>
<p>$$ L_S(h_w) &#x3D; \frac{1}{m}\sum_{i&#x3D;1}^{m}\left( h_w(x_i) - y_i \right)^2 $$</p>
<p>How to find the $ w $ that has a minimum loss with the previous formula?</p>
<ul>
<li>Least Squares</li>
</ul>
<p>Set the derivative of $ L_S(h_w) $ on $ w $ to zero: </p>
<p>$$ \frac{\partial{L_S(h_w)}}{\partial{w}} &#x3D; \frac{2}{m}\sum_{i&#x3D;1}^{m}\left( \langle w,x \rangle - y_i \right)x_i &#x3D; 0 $$</p>
<p>Denote $ A $ and $ b $ as:</p>
<p>$$ A &#x3D; \left( \sum_{i&#x3D;1}^{m}x_i x_i^T \right) $$<br>$$ b &#x3D; \left( \sum_{i&#x3D;1}^{m}y_i x_i \right) $$</p>
<p>We have:</p>
<p>$$ Aw &#x3D; b $$</p>
<p>If $ A $ is invertible, $ w &#x3D; A^{-1}b $<br>If not, $ w &#x3D; A^{+}b $. So, how to compute $ A^+ $?</p>
<ul>
<li>Gradient Decent</li>
</ul>
<p>An iterative algorithm pretty like the perceptron algorithm.</p>
<p>$$ w^{‘} &#x3D; w - \alpha \frac{\partial{L_S(h_w)}}{\partial{w}} $$</p>
<h3 id="Polynomial-Regression"><a href="#Polynomial-Regression" class="headerlink" title="Polynomial Regression"></a>Polynomial Regression</h3><p>Assume it’s a $ m $ degree polynomial regression problem:</p>
<p>If we only have one feature:</p>
<p>$$ y &#x3D; b_0 + b_1x + b_2x^2 + … + b_mx^m $$</p>
<p>If we have two features:</p>
<p>$$ y &#x3D; b_0 + b_1x_1 + b_2x_2 + b_3x_1^2 + b_4x_2^2 + b_5x_1x_2 + … $$</p>
<p>If we have more than two features, I don’t want to write it any more!</p>
<h3 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h3><p>It’s used for classification.</p>
<h4 id="binary-class"><a href="#binary-class" class="headerlink" title="binary class"></a>binary class</h4><p>$$ h_w(x) &#x3D; \frac{1}{1+e^{-\langle w,x \rangle}} $$</p>
<p>This is the form of sigmoid function. When $ \langle w,x \rangle $ is greater than zero, the output is greater than $ 0.5 $, it means we should classify $ x $ as a positive sample. Otherwise, we classify it negative.</p>
<p>As the output of $ h_w(x) $ is a real number between 0 and 1 (it always represents the probability of $ x_i $ is positve), it’s better to use negative log loss to represent to optimization problem.</p>
<p>Here we need to consider two cases: </p>
<ul>
<li><ol>
<li>labels are {0, 1}</li>
</ol>
</li>
</ul>
<p>$$ L_S(h_w) &#x3D; -\frac{1}{m}\sum_{i&#x3D;1}^{m}\left(y_i\log(h_w(x_i)) + (1-y_i)\log(1-h_w(x_i))\right)$$</p>
<ul>
<li><ol start="2">
<li>labels are {-1, 1}</li>
</ol>
</li>
</ul>
<p>$$ L_S(h_w) &#x3D; \frac{1}{m}\sum_{i&#x3D;1}^{m}\log(1+\exp(-y_i\langle w,x \rangle)) $$</p>
<p>We can use gradient decent algorithm to solve the problem. But I don’t want to write their derivatives!</p>
<h4 id="multiclass"><a href="#multiclass" class="headerlink" title="multiclass"></a>multiclass</h4><p>$$ h_w(x) &#x3D; \frac{e^{\langle w,x \rangle}}{\sum_{c&#x3D;1}^{k}e^{\langle w,x \rangle}} $$</p>
<p>Here $ k $ is the number of classes.</p>
<h4 id="loss-function"><a href="#loss-function" class="headerlink" title="loss function"></a>loss function</h4><p>$$ L_S(h_w) &#x3D; -\frac{1}{m}\sum_{i&#x3D;1}^{m}\sum_{c&#x3D;1}^{k}1[y_i &#x3D; c]\log(h_w(x_i)_c) $$</p>
<p>Here $ h_w(x_i)_c $ is the probability of $ x_i $ belonging to category $ c $. $ 1[y_i &#x3D; c] $ means this part is 1 if $ y_i &#x3D; c $, otherwise it’s 0.</p>
<h2 id="Other-models"><a href="#Other-models" class="headerlink" title="Other models"></a>Other models</h2><h3 id="Naive-Bayes"><a href="#Naive-Bayes" class="headerlink" title="Naive Bayes"></a>Naive Bayes</h3><p>It’s so simple, do we need to talk about it any more?</p>
<p>The biggest sometime unreasonable presumption when using Naive Bayes is all features are independent.</p>
<h3 id="Support-Vector-Machines"><a href="#Support-Vector-Machines" class="headerlink" title="Support Vector Machines"></a>Support Vector Machines</h3><h4 id="Hard-SVM-realizable"><a href="#Hard-SVM-realizable" class="headerlink" title="Hard-SVM (realizable)"></a>Hard-SVM (realizable)</h4><p>First, SVM is algorithm that solves binary classification problem. It returns a halfspace. The difference between SVM and the general halfspace is that SVM tries to find a halfspace that seperates samples with the largest possible margin. So what is margin? Margin is the minimum distance between a point in the training set and the hyperplane.<br>Let’s talk about the distance between a point and the hyperplane first. Say the hyperplane is represented as:</p>
<p>$$ \langle w,x \rangle + b &#x3D; 0 $$</p>
<p>Here $ w $ is a vector with length 1, and b is bias.</p>
<p>Now for any point $ x $, the distance from $ x $ to this hyperplane is:</p>
<p>$$ | \langle w,x \rangle + b | &#x3D; |w||x|\cos(\theta) + b $$</p>
<p>The inner product of $ w $ and $ x $ can be treated as a projection of $ x $ to $ w $. </p>
<p>Then the problem becomes to find a hyperplane that those points with the minimum distance to the hyperplane have the maximum distance.</p>
<p>$$ arg\max_w \min_{i \in m} y_i(\langle w,x_i \rangle + b) $$</p>
<p>It’s a quadratic optimization problem now. We have sufficient tool that can solve quadratic problems for us. What we need to do is generate those variables that are needed to be send into the QP function.</p>
<p>TODO: Math problem…</p>
<p><strong>We Cannot Use SGD to Solve Hard-SVM Problem</strong></p>
<h4 id="Soft-SVM-unrealizable"><a href="#Soft-SVM-unrealizable" class="headerlink" title="Soft-SVM (unrealizable)"></a>Soft-SVM (unrealizable)</h4><p>The contraints in Hard-SVM is:</p>
<p>$$ y_i(\langle w,x \rangle + b) \ge 1 $$</p>
<p>We introduce $ m $ nonnegative slack variables<br>$$ \xi_1 , …,  \xi_m $$</p>
<p>and relax the contraints as </p>
<p>$$ y_i(\langle w,x \rangle + b) \ge 1 - \xi_i $$</p>
<p><strong>We Can Use SGD to Solve Soft-SVM Problem</strong> (minimize hinge loss)</p>
<h4 id="Kernels"><a href="#Kernels" class="headerlink" title="Kernels"></a>Kernels</h4><p>Different definitions of distance between two points.</p>
<blockquote>
<p>kernel gallery:<a target="_blank" rel="noopener" href="http://crsouza.com/2010/03/17/kernel-functions-for-machine-learning-applications/">http://crsouza.com/2010/03/17/kernel-functions-for-machine-learning-applications/</a></p>
</blockquote>
<p><code>Kernel Trick</code> is used to faster the computation. Say we have to vectors $ x $ and $ y $ in $ d $ dimension. We use a function to increase them to $ m $ dimension where $ m $ is pretty big. Then we want to compute the similarity of these transformed vectors which is the result of inner product of them. It’s time-consuming if we do them sequentially. <code>Kernel</code> is used to make the computation faster.</p>
<ul>
<li>Polynomial Kernel</li>
</ul>
<p>$$ K(x, y) &#x3D; (c_1 \langle x,y \rangle + c_2)^{c_3} $$</p>
<p>If $ c_3 &#x3D; 1$, it is a linear kernel.</p>
<ul>
<li>Gaussian Kernel</li>
</ul>
<p>$$ K(x, y) &#x3D; \exp(\frac{-||x-y||^2}{c^2}) $$</p>
<ul>
<li>Sigmoind Kernel</li>
</ul>
<p>$$ K(x, y) &#x3D; tanh(\alpha x^Ty + c) $$</p>
<h3 id="Decision-Trees"><a href="#Decision-Trees" class="headerlink" title="Decision Trees"></a>Decision Trees</h3><p>The concept of decision tree is simple, the tricky part is how to build the decision tree. In class we talked about the greedy algorithm which minimize the gain in each step.</p>
<ul>
<li>build tree (ID3)</li>
</ul>
<p>First, the tree is empty, and we get a set of samples with size $ m $, each sample has $ d $ features. The current working node is root. We are going to build the subtree with the same principles until there is no more samples or no features to split on, or all samples are in the same label.</p>
<p>If we can split on this node, we will check all features to find the one that we have the maximum information gain.</p>
<p>Assume we are doing binary classification. On the current process, <code>data</code> is the set of samples we are going to split, and <code>i</code> is a feature index. If we split on this feature, the information gain is:</p>
<p>$$ gain(p(y_i &#x3D; 1)) - p(x_i &#x3D; True) * gain(p(y_i &#x3D; 1 | x_i &#x3D; True) + p(x_i &#x3D; False) * gain(p(y_i &#x3D; 1 | x_i &#x3D; False)) $$</p>
<p>$ gain $ is pre-defined gain function such as <code>train error</code>, <code>entropy</code>, <code>gini index</code>.</p>
<ul>
<li>prune tree</li>
</ul>
<p>We need to prune a decision tree because it may overfit. The rule for deleting a node is whether we can reduce validation error.</p>
<p>The pruning algorithm we implemented does only prune those nodes that both of its children are leaf nodes or one of them is a leaf node and the other is empty.</p>
<h4 id="Other-Decision-Tree-Algorithms"><a href="#Other-Decision-Tree-Algorithms" class="headerlink" title="Other Decision Tree Algorithms"></a>Other Decision Tree Algorithms</h4><ul>
<li>CART</li>
<li>C4.5</li>
</ul>
<p>The difference between these two algorithms and ID3 is how they choose the target attribute to split on. ID3 chooses the biggest information gain, while CART chooses the minimum gini index, and C4.5 chooses information gain ratio as an indicator. Both CART and C4.5 can be used to do a regression problem.</p>
<h2 id="Learning-theories"><a href="#Learning-theories" class="headerlink" title="Learning theories"></a>Learning theories</h2><h3 id="PAC-Learning"><a href="#PAC-Learning" class="headerlink" title="PAC Learning"></a>PAC Learning</h3><p>What’s PAC Learning? PAC learnability is a property of a hypothesis class on a specific data distribution. We say a hypothesis $ H $ is PAC learnable means if we have $ m $ training samples, it would be sufficient to guarantee that the overall loss is smaller than <code>epislon</code> with probability greater than <code>1-delta</code>.</p>
<p>So how can we use PAC Learnability to analysis a learning problem?</p>
<ul>
<li>If we have a set of training sample, we can estimate the accuracy with the given hypothesis class and a give confidence value <code>delta</code>. Or we can estimate the confidence of getting the given accuracy in the hypothesis class.</li>
<li>If we are given a requirement about accuracy and confidence, we can use PAC learnability to tell us how many samples we need to achieve the goal.</li>
</ul>
<h4 id="realizable-case"><a href="#realizable-case" class="headerlink" title="realizable case"></a>realizable case</h4><p>The presumpthion is that we can get a zero loss on this data distribution, and the hypothesis class is finite. Then the relation between <code>epsilob</code> (accuracy), <code>delta</code> (confidence), size of hypothesis class, and sample complexity is:</p>
<p>$$ m_H(\epsilon, \delta) \le \lceil \frac{log(|H|&#x2F;\delta)}{\epsilon} \rceil $$</p>
<h4 id="uniform-convergence"><a href="#uniform-convergence" class="headerlink" title="uniform convergence"></a>uniform convergence</h4><p>How can we eveluate the effectiveness of the ERM solution we get from the data set $ S $? If $ S $ is a good representation of distribution $ D $, then the ERM is good. How can we say a sample is representive?</p>
<p>If for any hypothesis $ h $ in $ H $:</p>
<p>$$ |L_S(h) - L_D(h)| \le \epsilon $$</p>
<p>We say data set $ S $ is <code>epsilon</code>-representative. Then if a data set $ S $ is <code>epsilon/2</code>-representative:</p>
<p>$$ L_D(h_S) \le \min_{h\in H}L_D(h) + \epsilon $$</p>
<p>Now we come to the uniform convergence property. It’s a property of a hypothesis class which represents the confidence of data set $ S $ is <code>epsilon</code>-representative.</p>
<p>$$ m_H^{UC}(\epsilon, \delta) \le \lceil \frac{log(2|H|&#x2F;\delta)}{2\epsilon^2} \rceil $$</p>
<p>It has almost the same meaning forms with PAC learnability.</p>
<h4 id="unrealizable-case"><a href="#unrealizable-case" class="headerlink" title="unrealizable case"></a>unrealizable case</h4><p>Here we do not assume we can find a hypothesis that perfectly works on the data set. We need to consider the representativeness of a data set.</p>
<p>$$ m_H(\epsilon, \delta) \le m_H^{UC}(\epsilon&#x2F;2, \delta) \le \lceil \frac{log(2|H|&#x2F;\delta)}{\epsilon^2} \rceil $$</p>
<h3 id="VC-Dimension"><a href="#VC-Dimension" class="headerlink" title="VC-Dimension"></a>VC-Dimension</h3><p>Pretty simple concept.</p>
<h3 id="Bias-Complexity"><a href="#Bias-Complexity" class="headerlink" title="Bias-Complexity"></a>Bias-Complexity</h3><p>Suppose we get a ERM solution $ h_S $. We use this hypothesis to test our testing data and get a loss value. The result can be divided into two parts:</p>
<p>$$ L_D(h_S) &#x3D; \epsilon_{app} + \epsilon_{est} $$</p>
<ul>
<li>approximation error: it’s bias because we choose the set of hypothesis. Even if we choose the best hypothesis in $ H $, this error cannot be eliminated.</li>
</ul>
<p>$$ \epsilon_{app} &#x3D; \min_{h\in H}L_D(h) $$</p>
<p>How to improve: increase the size of hypothesis class (it’s more possible to get a good hypothesis). Or choose some other features for the data set.</p>
<ul>
<li>estimation error: it’s normal to get an estimation error. But if it’s pretty high, it means our model is overfitting.</li>
</ul>
<p>How to improve: get more training samples, or reduce the size of hypothesis class.</p>
<h4 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h4><p>A mechanism used to prevent overfitting. When we are doing optimization, we do only care about the training loss before. Now we add another component into the optimization function which represents the complexity of hypothesis class.</p>
<p>How to set the value?</p>
<ul>
<li>Tikhonov Regularization</li>
</ul>
<p>$$ R(w) &#x3D; \lambda||w||_2^2 $$</p>
<h4 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h4><p>We want to use boosting because in regularization we already <code>lambda</code> to zero while the approximation error is still very high. Then we combine several hypotheses together, and consider each vote to determine the final label. We say the single hypothesis used in boosting is <code>weak learner</code>, and the combined hypothesis is <code>strong learner</code>.</p>
<ul>
<li>AdaBoost</li>
</ul>
<p>We have a set of samples, each sample has an initial weight. Let’s denote the initial weight list as $ D^0 $. We have a weak learner, which will return a hypothesis with $ D $ and $ S $. Then we will go several iterations to update $ D $ and get a list of hypothesis. Finally we will use the set of hypotheses to predict testing samples.</p>
<p>The meaning of $ D $ in each iteration is that if we correctly classified the sample, the weight of sample would decrease. Otherwise the weight increases. It makes sure that we will focus more on the falsely classified samples. Each hypothesis also has a weight which is represented by the training error in that iteration. So the final predication is an average sum of all predictions from all hypotheses.</p>
<h2 id="Clustering-Algorithms"><a href="#Clustering-Algorithms" class="headerlink" title="Clustering Algorithms"></a>Clustering Algorithms</h2><h3 id="K-Nearest-Neighbors"><a href="#K-Nearest-Neighbors" class="headerlink" title="K-Nearest Neighbors"></a>K-Nearest Neighbors</h3><p>For every sample in the training set, the 1-Nearest Neighbor is the sample itself. So the VC Dimension of 1-Nearest Neighbor Algorithm is infinite.</p>
<p>The algorithm is so simple that I cannot find anything to write.</p>
<p>If we have $ m $ training samples, the time complexity of classifying one test sample is $ O(mlogk) $</p>
<h3 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h3><p>First we need to choose k centroids randomly from m samples.</p>
<p>Then iteratively go through all samples, assign the label of its nearest centroid to the sample, and after that, update centroids by averaging all samples in the same cluster.</p>
<p>The stopping condition is if the different between the current centroids and the new centroids is smaller than a constant value.</p>
<p>We have several choices for distance functions:</p>
<ul>
<li>Euclidean Distance</li>
<li>Manhattan Distance</li>
<li>Chebychev Distance</li>
</ul>
<h3 id="Expectation-Maximization"><a href="#Expectation-Maximization" class="headerlink" title="Expectation Maximization"></a>Expectation Maximization</h3><p>The problem that EM algorithm tries to solve is that we get some data samples, assuming they are belonging to k different Gaussians distributions. We do not know the labels of each data, but we want to prediction the means and variances of these Gaussians distributions such that we get the highest probability to get the data samples we have.</p>
<p>First, we should generate random values for all parameters for those distritbutions. Then this algorithm can be divided into two steps:</p>
<ul>
<li>Expectation step:</li>
</ul>
<p>For each sample, compute the probabilities of the sample belonging to each distributions. We need the prior probabilities $ p(c) $, and then for sample $ x $, the probability of $ x $ belonging to $ c $ is:</p>
<p>$$ p(c\ |\ x) \approx p(c)*p(x\ |\ c) $$</p>
<p>When computing $ p(x\ |\ c) $, we are using the parameters of $ c $ in the current iteration. We will update the parameters in M step.</p>
<ul>
<li>Maximization step:</li>
</ul>
<p>Now we have labeled all samples. We can use the samples in each cluster to compute its mean and variance.</p>
<p>$$ \mu_c &#x3D; \frac{\sum_{i&#x3D;1}^{m}x_ip(c\ |\ x_i)}{\sum_{i&#x3D;1}^{m}p(c\ |\ x_i)} $$</p>
<p>Here $ p(c\ |\ x_i) $ is the value from E step after normalization.</p>
<p>$$ \sigma_c^2 &#x3D; \frac{\sum_{i&#x3D;1}^{m}p(c\ |\ x_i)(x_i - \mu_c)(x_i - \mu_c)^T}{\sum_{i&#x3D;1}^{m}p(c\ |\ x_i)}$$</p>
<p>In addition to updating mean and variance, we should also update the prior probabilities:</p>
<p>$$ p(c) &#x3D; \frac{\sum_{i&#x3D;1}^{m}p(c\ |\ x_i)}{m}$$</p>
<blockquote>
<p>A detailed explanation can be found here: <a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCs7alOMRnxhzfKAJ4JjZ7Wg">https://www.youtube.com/channel/UCs7alOMRnxhzfKAJ4JjZ7Wg</a></p>
</blockquote>
<h3 id="Principal-Component-Analysis"><a href="#Principal-Component-Analysis" class="headerlink" title="Principal Component Analysis"></a>Principal Component Analysis</h3><p>PCA is an algorithm projecting $ d $ dimension samples into a lower dimension subspace with a minimum information loss.</p>
<p>The definition of information loss:</p>
<p>$$ loss &#x3D; \sum_{i&#x3D;1}^{m}||x_i - UU^Tx_i||_2^2 $$</p>
<p>Assume we want to reduce the dimension from $ d $ to $ n $, then here $ U $ is a $ d*n $ matrix, and we have $ U^TU &#x3D; I $.</p>
<p>The problem is to find $ n $ principal components $ u_1 $, …, $ u_n $ </p>
<p>Let’s assume we have $ m $ training samples:</p>
<ul>
<li>If $ m &gt; d $</li>
</ul>
<p>$$ A &#x3D; X^TX $$</p>
<p>Let $ u_1 $, …, $ u_n $ be the eigenvectors of A with largest eigenvalues.</p>
<ul>
<li>If $ m &lt;&#x3D; d $</li>
</ul>
<p>$$ B &#x3D; XX^T $$</p>
<p>Let $ v_1 $, …, $ v_n $ be the eigenvectors of B with largest eigenvalues. For each $ v_i $, we get a corresponding $ u_i $:</p>
<p>$$ u_i &#x3D; \frac{1}{||X^Tv_i||}X^Tv_i$$</p>
<p>@Providence</p>

 
                <!-- Meta -->
                <div class="post-meta">
                    <hr>
                    <br>
                    <div class="post-tags">
                        
                    </div>
                    <div class="post-date">
                        05 / 10 / 2019
                    </div>
                </div>
            </div>

            <!-- Comments -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- Disqus Comments -->


            </div>
        </div>
    </div>
</article>
</section>

    <!-- Scripts -->
    <!-- jQuery -->
<script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<!-- Bootstrap -->
<script src="//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

	<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script type="text/javascript">
	console.log('Hexo-theme-hollow designed by zchen9 🙋 © 2015-' + (new Date()).getFullYear());
</script>

    <!-- Google Analytics -->
    

</body>

</html>